# Documentation for the Ontological Programming Paradigm

Welcome to the documentation hub for a new way of thinking about software. This collection of documents outlines **Ontological Programming**, a paradigm that shifts focus from "doing" to "being," and its practical implementation, **Ray.Framework**.

Here, you will not just find technical specifications, but a complete philosophy for building software that is reliable, understandable, and correct by its very nature.

## Reading Guide: Where to Start

We recommend reading the documents in order, as each builds upon the concepts of the previous one. This journey will take you from high-level philosophy to concrete implementation patterns.

### 1. **[Ontological Programming: A New Paradigm](./philosophy/ontological-programming-paper.md)**

> **"What if we programmed by defining what can exist, rather than what should happen?"**

**Start here.** This is the foundational philosophical paper that introduces the core ideas of Ontological Programming. It establishes the "Why?" behind this entire ecosystem.

*   **Read this to understand:**
  * The core crisis in traditional programming ("The Crisis of Doing").
  * The five fundamental principles of existence-driven design.
  * How this paradigm promises to eliminate entire classes of errors.
  * The role of the programmer in the age of AI.

### 2. **[Ray.Framework: Programming as Metamorphosis](./framework/ray-framework-whitepaper.md)**

> **"Objects are processed through constructor injection, just as light rays pass through a prism - instant, pure, and transformed."**

This whitepaper details **Ray.Framework**, the concrete PHP implementation of Ontological Programming. It translates the abstract philosophy into a practical, powerful tool.

*   **Read this to understand:**
  * How constructors become "workshops" for self-transformation.
  * The Metamorphosis Pattern (`Egg → Larva → Pupa → Butterfly`).
  * The duality of linear chains and parallel assemblies for data flow.
  * How automatic streaming and type transparency are achieved.

### 3. **[From Space to Time: The Metamorphosis Paradigm](./philosophy/from-space-to-time.md)**
   > **"When code learned to remember, programs discovered mortality, and programming became poetry"**

   The crystallization of our deepest understanding. This essay transforms programming from spatial navigation to temporal metamorphosis.

    * **Read this to experience:**
        * The shift from eternal present to lived time
        * Programming as poetry and philosophy
        * The quantum nature of existence in code

### 4. **[The Metamorphosis Architecture Manifesto](./patterns/metamorphosis-architecture-manifesto.md)**

> **(This document is implicitly referenced, but would be the next logical step)**

This manifesto is the practical "how-to" guide for architects and developers. It provides detailed patterns, testing strategies, and conventions for building systems with Ray.Framework.

*   **Read this to learn:**
  * The `Type-Driven Metamorphosis` pattern for handling conditional logic.
  * The `Unchanged Name Principle` for maintaining semantic continuity.
  * Advanced testing strategies for ontological systems.

### 5. **[The #[Accept] Pattern: Ontological Delegation](./patterns/accept-pattern-ontological-delegation.md)**

> **"The highest intelligence is knowing when to seek the wisdom of others."**

This document introduces a mature pattern for handling real-world complexity. It addresses the question: "What happens when an object cannot determine its own existence?"

*   **Read this to explore:**
  * How to model delegation to experts (`Physician`, `Lawyer`, `Engineer`).
  * The `Undetermined` state and the `#[Accept]` attribute.
  * How this pattern makes systems more robust and realistic.

### 6. **Supporting Documents: The Ecosystem Tools**

These documents describe the powerful tooling and integrations that emerge from this paradigm.

*   **[Architecture as Documentation](./framework/architecture-as-documentation.md)**
  * Discover how the architecture itself becomes the ultimate, always-up-to-date documentation.
  * Learn about the `ray-tree` command for automatically visualizing your system's structure, semantics, and data flows.

*   **[ALPS and Ray.Framework: Bidirectional Generation](./alps-ray-bidirectional-generation.md)**
  * Explore the revolutionary concept of bidirectional generation between design specifications (ALPS) and executable code.
  * See how a single, protocol-agnostic design can generate REST, GraphQL, or gRPC APIs.

## The Complete Vision

This collection of documents presents more than just a framework. It offers a complete, cohesive vision for software development where:

*   **Philosophy** (`Ontological Programming`) provides the "Why".
*   **Implementation** (`Ray.Framework`) provides the "How".
*   **Patterns** (`#[Accept]`, `Metamorphosis`) provide the "What".
*   **Tooling** (`Architecture as Documentation`, `ALPS Generation`) provides the "With".

We invite you to embark on this journey and discover a new way to create software—not by writing fragile instructions, but by defining robust, beautiful, and correct existences.

---

# 存在論的プログラミング・パラダイムのドキュメント

ソフトウェアについての新しい考え方へようこそ。このドキュメント群は、「何をするか」から「何であるか」へとフォーカスを移す**存在論的プログラミング**とその実装である**Ray.Framework**を紹介します。

ここでは技術仕様だけでなく、本質的に信頼性が高く、理解しやすく、正しいソフトウェアを構築するための完全な哲学を見つけることができます。

## 読書ガイド：どこから始めるか

各文書は前の概念を基に構築されているため、順番に読むことをお勧めします。この旅は、高レベルの哲学から具体的な実装パターンまでを案内します。

### 1. **[存在論的プログラミング：新しいパラダイム](./philosophy/ontological-programming-paper.md)**

> **「何が起こるべきかではなく、何が存在できるかを定義してプログラムを書いたらどうだろうか？」**

**ここから始めてください。** これは存在論的プログラミングの核心となる考えを紹介する基礎的な哲学論文です。この全体的なエコシステムの「なぜ？」を確立します。

*   **理解すべき内容:**
    *   従来のプログラミングにおける核心的な危機（「行動の危機」）
    *   存在駆動設計の5つの基本原則
    *   このパラダイムが約束する全体的なエラークラスの排除
    *   AI時代におけるプログラマーの役割

### 2. **[Ray.Framework：変容としてのプログラミング](./framework/ray-framework-whitepaper.md)**

> **「オブジェクトは光線がプリズムを通過するように、コンストラクタ注入を通じて処理される—瞬間的で、純粋で、変容される。」**

この白書では、存在論的プログラミングの具体的なPHP実装である**Ray.Framework**を詳述します。抽象的な哲学を実用的で強力なツールに変換します。

*   **理解すべき内容:**
    *   コンストラクタが自己変容の「工房」となる方法
    *   変容パターン（`卵 → 幼虫 → 蛹 → 蝶`）
    *   データフローにおける線形チェーンと並列アセンブリの二重性
    *   自動ストリーミングと型透明性の実現方法

### 3. **[変容アーキテクチャ・マニフェスト](./patterns/metamorphosis-architecture-manifesto.md)**

> **（この文書は暗黙的に参照されていますが、次の論理的ステップとなります）**

このマニフェストは、アーキテクトと開発者のための実用的な「ハウツー」ガイドです。Ray.Frameworkを使用してシステムを構築するための詳細なパターン、テスト戦略、規約を提供します。

*   **学ぶべき内容:**
    *   条件ロジックを処理するための`型駆動変容`パターン
    *   意味論的継続性を維持するための`名前不変原則`
    *   存在論的システムのための高度なテスト戦略

### 4. **[#[Accept]パターン：存在論的委譲](./patterns/accept-pattern-ontological-delegation.md)**

> **「最高の知性は、他者の知恵を求める時を知ることである。」**

この文書では、現実世界の複雑さを処理するための成熟したパターンを紹介します。「オブジェクトが自らの存在を決定できない場合はどうなるか？」という問いに答えます。

*   **探求すべき内容:**
    *   専門家（`医師`、`弁護士`、`エンジニア`）への委譲のモデル化
    *   `未決定`状態と`#[Accept]`属性
    *   このパターンがシステムをより堅牢で現実的にする方法

### 5. **サポート文書：エコシステムツール**

これらの文書では、このパラダイムから生まれる強力なツールと統合について説明します。

*   **[ドキュメントとしてのアーキテクチャ](./framework/architecture-as-documentation.md)**
    *   アーキテクチャ自体が最終的な、常に最新のドキュメントとなる方法を発見
    *   システムの構造、意味論、データフローを自動的に可視化する`ray-tree`コマンドについて学習

*   **[ALPSとRay.Framework：双方向生成](./alps-ray-bidirectional-generation.md)**
    *   設計仕様（ALPS）と実行可能コード間の双方向生成の革命的概念を探求
    *   単一のプロトコル非依存設計がREST、GraphQL、またはgRPC APIを生成する方法を確認

## 完全なビジョン

このドキュメント群は単なるフレームワーク以上のものを提示します。ソフトウェア開発のための完全で一貫したビジョンを提供します：

*   **哲学**（`存在論的プログラミング`）が「なぜ」を提供
*   **実装**（`Ray.Framework`）が「どのように」を提供
*   **パターン**（`#[Accept]`、`変容`）が「何を」を提供
*   **ツール**（`ドキュメントとしてのアーキテクチャ`、`ALPS生成`）が「何によって」を提供

私たちは、この旅に乗り出し、ソフトウェアを作成する新しい方法を発見することをお勧めします—脆弱な指示を書くのではなく、堅牢で美しく、正しい存在を定義することによって。
